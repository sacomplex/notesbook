[TOC]

# 初步了解事件
- 定义： 
    - Event：“能够发生的什么事件”
    - 事件 = 通知 + 可选的事件参数
- 角色:
    - 使对象或类具备通知能力的成员
    - 对象拥有一个事件：当事件发生时，该对象有能力通知别的对象
- 使用:
    - 用于对象或类间的动作协调与信息传递
- 原理:
    - 事件模型:
    - 事件的组成:
    - "发生->响应"这一过程的5个动作:
        - 我有一个事件
        - 一个人或一群人关心我的这个事件
        - 我的设个事件发生了
        - 关心这个事件的人会被依次通知到
        - 被通知到的人根据拿到的事件信息(EventArgs:事件数据,事件参数,通知)对事件进行响应(Event Handler:事件处理)
    - ==事件的订阅者==/事件消息的接受者/事件的响应者/事件的处理者被事件所通知的对象
    - ==事件参数==/事件信息/事件消息/事件数据
- 提示
    - 事件多用于桌面,手机等开发的客户端编程,因为这些程序经常是用户通过事件来驱动的
    - 各种编程语言对这个机制的实现方法不尽相同
    - Java没有事件成员,有没有委托,而是通过接口实现
    - MVC,MVP,MVVM等模式,是事件模式更高级,更有效的用法
    - 开发中,使用已有事件的机会比较多,自己声明事件的机会比较少

## 事件基于委托
- 事件需要使用委托类型进行约束,约束规定了事件发送给事件响应者的消息,也就是规定了事件的响应者收到的来自事件发送者的消息.这就要求事件响应者的事件处理器必须与这个约束进行匹配,这样才能订阅事件
- 当事件的响应者向事件的拥有者提供了能够匹配约束的事件处理器时,委托的实例来保存事件处理器

# 事件的应用

## 实例演示
- 派生(继承)与扩展
- 事件的拥有者在完成某个逻辑之后,告诉事件发出通知
- 按下按钮举例:
    - 鼠标按下按钮->用户的鼠标向计算机硬件发送电讯号
    - Windows记录下鼠标指针在屏幕的当前位置->若系统发现当前指针位置有一个按钮,并且包含按钮的窗口处于激活状态时->通知按钮,你被用户按下
    - 执行按钮自己的内部逻辑->重新绘制按钮的样子(被按下的样子),并记录状态
    - 鼠标放下->系统将消息传递给按钮->按钮再重新绘制为未被按下的样子,并标记为未被下状态
    - 按钮内部逻辑检测到这2个状态,从而得知自己被点击了,然后调用点击事件来通知外界自己被点击了
    - 若有其他对象订阅了点击事件,事件的订阅者就会开始工作了

## 事件模型的五个组成部分
- 事件的拥有者(event source, 对象)
    - 事件成员(event, 成员)
- 事件的响应者(event subscriber, 对象):即订阅了事件的对象
    - 事件处理器(event handler, 方法成员),本质上是一个回调方法
- ==事件订阅==,把事件处理器与事件关联在一起,本质上是一种以委托为基础的约定
    - 当事件发生时,事件拥有者会通知谁
    - 用什么事件处理器处理事件
    - 用什么具体方法处理事件  

### 组成方式
1. (事件的拥有者 (事件的响应者(事件处理器)) <-订阅- (事件))  
2. `*` 事件机模式的原型:(事件的拥有者(事件)) <-订阅- (事件的响应者(事件处理器)) 
    - 事件拥有者和响应者是两个不同的对象
3. `**`:(事件的拥有者,事件的响应者 (事件 )<-订阅- (事件处理器)) 
    - 事件拥有者和事件响应者是同一个对象
4. `***`:(事件的响应者 (事件的拥有者(事件)) <-订阅- (事件处理器)) 
    - 事件拥有者是事件响应者的一个字段成员
    - 窗口对象内有个按钮,窗口订阅按钮的点击事件
    - Windows默认的事件处理模式

#### 补充  
1. 一个事件处理器可以处理多个相同约束的事件   
2. 一个事件可以对应多个事件处理器
例如可以用一个事件处理器对多个按钮进行处理  
3. 事件处理器挂接方式2:使用委托
`this.button.Click += new EventHandler(this.ButtonClicked);`  
4. 事件处理器挂接方式3:使用delegate匿名方法(已经被淘汰了)
5. 事件处理器挂接方式4:lambda表达式
6. WPF
    - 可以在XAML中挂接事件
    - WPF中使用路由事件

## 注意
- 事件处理器是方法成员
- 挂接事件处理器的时候,可以使用委托实例,也可以直接使用方法名,这是个语法糖
- 事件处理器对事件的订阅不是随意的,匹配与否由声明事件时所使用的委托类型来检测
- 事件可以同步调用也可以异步调用

# 深入理解事件

# 事件的声明

## 事件的声明
- 完整声明
    - 不要混淆==声明委托类型==和==使用委托类型的一个类声明一个委托类型的字段==
```
// <自定义事件,事件的完整声明方式
    public class Customer {
        private OrderEventHandler orderEventHandler;// 委托字段,存储事件处理器

        public event OrderEventHandler Order { // 声明事件
            // 添加器
            add { this.orderEventHandler += value; }
            // 移除器
            remove { this.orderEventHandler -= value; }
        }
    
        public double Bill { get; set; }    // 账单
        
        // 略
    }
```
- 简略声明
```
// <自定义事件,事件的简化声明方式

    public class Customer {
        public event OrderEventHandler Order; // C#语法糖:简化声明事件,此处事件并不是一个字段

        public double Bill { get; set; }    // 账单
        
        // 略
    }
```
## 需要事件的原因
- 为了程序的逻辑更加安全,
- 可以防止潜在的问题
    - 更改代码后测试`EventExample7_Why_Event`
    - 结果badGuy可以随意替顾客点菜

## 事件的本质
- 事件的本质是委托字段的包装器
- 事件对委托字段的访问起到限制作用
- 封装是一个重要功能就是隐藏
- 事件对外隐藏了委托实例的大部分功能,仅暴露添加/移除事件处理器的功能

## 用于声明事件的委托类型的命名约定 
- 用于声明Foo事件的委托,一般命名为FooEventHandler(除非是一个非常通用的事件约束,例如EventHandler)
- FooEventHandler委托的参数一般用两个(由Win32API演化而来)   
    - 第一个是object类型sender,即事件的拥有者
    - 第二个EventArgs类的派生FooEventArgs e,即事件参数
    - 可以把委托的参数列表看作事件发生后发送给事件响应者的事件参数
- 触发Foo事件的方法一般命名为OnFoo
    - 访问级别为projected,不能为public

## 事件的命名约定
- 带有时态的动词或短语
- 事件拥有者正在做什么事情,用进行时
- 事件拥有者做完了什么事情,用完成时

# 问题辨析
