# 01 计算机系统漫游

- 计算机系统 = 硬件 + 软件

- 所有计算机系统都有相似的硬件和软件组成，它们又执行相似的功能

```c
#include <stdio.h>

int main(){
    printf("hello, world\n");
    return 0;
}
```



- 本书的目的帮助了解当在系统上执行`hello`程序时,系统发生了什么以及问什么会这样
  - 通过跟踪`hello`程序的生命周期来开始系统学习:从它被程序员创建开始,到在系统上运行,输出简单的消息,然后终止

## 1.1 信息就是位 + 上下文

- `hello`程序的生命周期的开始从一个源程序(或者说源文件)开始的

- 源程序实际上是由值0和1组成的位(比特bit)序列,8个位被组成一组,称为字节
  - 每个字节表示程序中的某些文本字符

- 大部分现代计算机系统都使用ASCII标准来表示文本字符
  - 用一个唯一的单字节大小的整数值来表示每个字符

![](D:\github\notebook\计算机基础课程\操作系统\Computer Systems A Programmer's Perspective 深入理解计算机系统\01 计算机系统漫游\images\01.png)

`hello.c`程序是以字节序列的方式存储在文件中的.每个字节都有一个整数值,对应于某些字符

一个基本思想

- 系统中所有的信息,包括磁盘文件,内存中的程序,内存存放的用户数据以及网络上传送的数据,都是由一串比特表示的
- 区分不同数据对象的唯一方法是:读取数据对象的上下文

数字的机器表示方式与实际的整数和实数是不同的,是对真值的有限近似值

## 1.2 程序被其他程序翻译成不同的格式

`hello`程序的生命周期从高级C语言程序开始的.

为了在系统上运行hello.c程序,每条C语句都必须被其他程序转化为一系列的敌机机器语言指令.然后这些指令按照一种称为可执行目标程序(可执行目标文件)的格式打好包,并以二进制磁盘文件的形式存放起来.

在Unix系统上,从源文件到目标文件的转化是由编译器驱动程序完成的

```shell
linux > gcc -o hello hello.c
```

GCC 编译器驱动程序读取源程序文件`hello.c`,并把它翻译成一个可执行目标文件`hello`

这个翻译过程分为四个阶段:

- 预处理器->编译器->汇编器->链接器
- 这四个阶段构成了编译系统

![](D:\github\notebook\计算机基础课程\操作系统\Computer Systems A Programmer's Perspective 深入理解计算机系统\01 计算机系统漫游\images\02.png)

**预处理器(cpp)**

- 预处理器根据字符`#`开头的命令,修改原始的C程序
  - 比如`#include <stdio.h>`命令告诉预处理器读取系统头文件`stdio.h`的内容,并把它直接插入程序文本中.得到了另一个C程序,通常是以`.i`作为文件扩展名

**编译阶段(ccl)**

- 编译器将文本文件`hello.i`翻译成文本文件`hello.s`,它包含一个汇编语言程序.该程序包含函数`main`的定义

```assembly
main:
	subq $8, %rsp
	movl $.LCD, %edi
	call puts
	movl $0, %eax
	addq $8, %rsp
	ret
```

**汇编阶段(as)**

- 汇编器将`hello.cs`翻译成机器语言指令,并把这些指令打包成可重定位目标衡虚的格式,并将结果保存在目标文件`hello.o`中.`hello.o`文件是一个二进制文件,包含的是函数`main`的指令编码

**链接阶段(ld)**

- `hello`程序调用了`printf`函数.`printf`函数存在于一个名为`printf.o`的单独的预编译的目标文件中..链接器负责将`printf.o`以某种方式合并到`hello.o`程序中

## 1.3 了解编译系统如何工作是大有益处的

编译系统是如何工作

- 优化程序性能
  - switch语句是否比一系列`if-else`语句高效
  - 一个函数调用的开销
  - while循环是否比for循环更高效
  - 指针引用比数组索引是否更有效
  - ...
  - 详解的见第3,5,6章
- 理解链接时出现的错误
  - 详解见第7章
- 避免安全漏洞
  - 详见第3章

## 1.4 处理器读并解释存储在内存中的指令

到这里,`hello.c`源程序已经被编译系统翻译成了可执行目标文件`hello`,并被存放在磁盘上.

在Unix系统上运行该可执行文件,需要使用shell(命令解释器)

```shell
linux> .hello
hello, world
linux>
```

#### 1.4.1 系统的硬件组成

![](D:\github\notebook\计算机基础课程\操作系统\Computer Systems A Programmer's Perspective 深入理解计算机系统\01 计算机系统漫游\images\03.png)

**总线**

- 贯穿整个系统的电子管线
- 携带信息字节并负责在各个部件间传递
- 总线一般被设计成传送定长的字节快(字word)
  - 字中的字节数(字长)是一个基本参数,各个系统都不尽相同
  - 8个字节(64位)或4个字节(位)

**I/O设备**

- 输入/输出设备是系统与外部世界的联系通道
  - 用户输入的键盘和鼠标
  - 用户输出的显示器
  - 用于长期存储数据和程序的磁盘驱动器
- 每个I/O设备都通过一个控制器或适配器与I/O总线相连
  - 控制器和适配器的区别在于封装方式
    - 控制器是I/O设备本身或者系统的主印制电路板(主板)上的芯片组
    - 适配器是一块插在主板插槽上的卡
- 详见第六章

**主存**

- 主存是一个临时存储设备
- 在处理器执行程序时,用来存放程序和程序处理的数据
- 物理上
  - 主存是由一组动态随机存储器(DRAM)芯片组成的
- 逻辑上
  - 存储器是一个线性的字节数组,每个字节都有唯一的地址(数组索引),这些地址是从零开始的
- 一般,组成程序的每条机器指令都由不同数量的字节构成
- 详见第六章

**处理器**

- 中央处理单元是解释(或执行)存储在主存中指令的引擎
- 处理器的核心是一个大小为一个字的存储设备(寄存器),被称为程序计数器(PC)
- 在任何时刻,PC都指向主存中的某条机器语言指令(即含有该条指令的地址)
- 从系统通电开始,直到系统断电,处理器一直在不断地执行程序计数器指向的指令,再更新程序计数器,使其指向下一条指令.处理器按照一个指令执行模型(指令集架构)来操作.在这个模型中,指令按照严格的顺序执行,而执行一条指令包含执行一些列的步骤.
  - 处理器从PC指向的内存处读取指令,解释指令中的位,指向该指令指示的简单操作,然后更新PC,使其指向下一条指令,而这条指令并不一定在和内存中刚刚执行的指令相邻
  - 这样的简单操作,围绕着主存,寄存器文件和算术/逻辑单元(ALU)进行
    - 寄存器文件是一个小的存储设备,由一些单个字长的寄存器组成,每个寄存器都有唯一的名字
    - ALU计算新的数据和地址值
- 例子
  - 加载:从主存复制一个字节或者一个字到寄存器,以覆盖寄存器原来的内容
  - 存储:从寄存器复制一个字节或者一个字到主存的某个位置,以覆盖这个位置上原来的内容
  - 操作:把两个寄存器的内容复制到ALU,ALU对着两个字做算术运算,并将结果放到一个寄存器中,以覆盖该寄存器中原来的内容
  - 跳转:从指令本身中抽取一个字,并将这个字复制到程序计数器(PC)中,以覆盖PC中原来的值
- 处理器的指令集架构描述的是每条机器代码指令的效果
- 处理器的微体系结构描述的是处理器实际上如何实现的
- 详见第3,4,5章

### 1.4.2 运行`hello`程序

开始介绍当运行示例程序时发生了什么

- 初始时,shell程序执行指令,等待输入一个命令:在键盘上输入字符串`"./hello"`后,shell程序将字符逐一读入寄存器,再把它存放到内存中

![](D:\github\notebook\计算机基础课程\操作系统\Computer Systems A Programmer's Perspective 深入理解计算机系统\01 计算机系统漫游\images\04.png)

- 当在键盘上敲回车键时,shell程序就知道已经结束了命令的输入.然后shell执行一系列指令来加载可执行的hello文件,这些指令经hello目标文件的代码和数据从磁盘复制到主存数据包括最终会被输出的字符串`"hello, world\n"`
- 利用直接存储器存取(DMA)技术,数据可以不通过处理器而直接从磁盘到达主存

![](D:\github\notebook\计算机基础课程\操作系统\Computer Systems A Programmer's Perspective 深入理解计算机系统\01 计算机系统漫游\images\05.png)

- 一旦目标文件hello文件中的代码和数据被加载到主存,处理器就开始执行hello程序的main程序中的机器语言指令.这些指令将`"hello, world\n"`字符串中的字节从主存复制到寄存器文件,再从寄存器文件中复制到显示设备,最终显示在屏幕上

![](D:\github\notebook\计算机基础课程\操作系统\Computer Systems A Programmer's Perspective 深入理解计算机系统\01 计算机系统漫游\images\06.png)

## 1.5 高速缓存至关重要

重要问题: 系统花费了大量的时间把信息从一个地方挪到另一个地方
- `hello`程序的机器指令最初是存放在磁盘上,当程序加载时,它们被复制到主存
- 当处理器运行程序时,指令又从主存复制到处理器
- 数据串`"hello, world\n"`开始时再磁盘上,然后被复制到主存,最后从主存上复制到显示设备

根据机械原理:
- 较大的存储设备要比较小的存储设备运行得最慢
- 快速设备的造价高于同类的低速设备

一个寄存器文件只存储几百字节的信息,而主存里可存放几十亿字节   
然而,处理器从寄存器文件中读数据比从主存中读取几乎要快100倍
加快处理器的运行速度比加快主存的运行速度要容易和便宜得多

针对这种处理器与主存之间的差异,系统设计采用更小更快的存储设备, 即高速缓存存储器(cache memory), 作为暂时的集结区域,存放处理器近期可能会需要的信息.
![](D:\github\notebook\计算机基础课程\操作系统\Computer Systems A Programmer's Perspective 深入理解计算机系统\01 计算机系统漫游\images\07.png)

- 位于处理器芯片上的L1高速缓存的容量可达数万字节,访问速度几乎和访问寄存器文件一样快. 
- 一个容量为数十万到数百万的更大的L2高速缓存通过一条特殊的总线连接到处理器.
- 进程访问L2高速缓存的时间要比访问L1高速缓存的时间长5倍,但是仍然比访问主存的时间快5~10倍.
- L1和L2高速缓存是用静态随机访问存储器(SRAM)的硬件技术实现的
- 一些更新,更强大的处理器甚至有三级高速缓存:L1,L2和L3

系统可以获得一个很大的存储器,同时访问速度也很快
  - 原因:利用了高速缓存的局部性原理
      - 即程序具有访问局部区域里的数据和代码的趋势

通过高速缓存里存放可能经常访问的数据,大部分的内存操作都能在快速的高速缓存中完成

详见第六章

## 1.6 存储设备形成层次结构

## 1.7 操作系统管理硬件

## 1.8 系统之间利用网络通信

## 1.9 重要主题



