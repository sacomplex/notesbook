# 程序性能分析



  ## 数学基础

  ### 指数

### 对数

  ### 级数

  最容易记忆的公式:   

  - $\sum_{i=0}^{N}2^i = 2^{N+1}-1$      
  - $\sum_{i=0}^{N}A^i = \frac{A^{N+1}}{A-1}$    
    - 若其中$0<A<1$时,$\sum_{i=0}^{N}A^i \leqslant \frac{1}{1-A}$  

  #### 几何级数

  当$N \rightarrow \infty$时,这些公式是几何级数(geometric series)   

  推导:$\sum_{i=0}^{\infty}A^i = \frac{1}{1-A},0<A<1$的公式:   

  - 利用令$S$其和,然后与$AS$相减,可得$S-AS=1,S = \frac{1}{1-A}$
    - 只对收敛级数进行
    - 例如$S = \sum_{i=1}^\infty\frac{i}{2^i}, 2S - S = S = \sum_{i=0}^\infty\frac{1}{2^i} = 2$

  几何级数: 与末项同阶 

  - $\sum_{k \to 0}^n a^k = O(a^n)$

  #### 算术级数

  算数级数: 与末项平方同阶  

  $\sum_{i=1}^{N} = \frac{N(N+1))}{2} \approx \frac{N^2}{2} = O(N^2)$   
  $\sum_{i=1}^{N}i^2=\frac{N(N+1)(2N+1)}{6}\approx = \frac{N^3}{3} = O(N^3)$   
  $\sum_{i=1}^{N}i^k \approx \frac{N^{k+1}}{|k+1|} = O(N^k),k\neq-1$    

  #### 调和数

  调和和:$H_N = \sum_{i=1}^{N} \frac{1}{i} \approx log_{e^N}$      

  - 近似误差为欧拉常数:$\gamma \approx 0.577 215 66$

  #### 其他

  $\sum_{i=1}^{N}f(N) = Nf(N)$    
  ==$\sum_{i=n_0}^{N}f(i) = \sum_{i=1}^{N}f(i) - \sum_{i=n_0}^{n_0-1}f(i) $==

  ### 证明方法

  #### 归纳证明法(induction)  

  - 第一步:证明基准情形(base case)
    - 确定定理对于某个(某些)小的(通常是退化的)值的正确性
  - 第二步:归纳假设(inductive hypothesis)
    - 指的是假设定理对直到某个有限数$k$的所有情况都是成立的.
  - 第三步:使用第二步的假设,证明定理对下一个值(通常是$k+1$)也是成立的

  举例:

  - 证明:斐波那契数列$F_i < {(5/3)}^i$
  - 证明:$\sum_{i=1}^{N}i^2=\frac{N(N+1)(2N+1)}{6}$

  #### 反证法(proof by contracdiction)  

  通过假设假设定理不成立,然后证明该假设导致某个已知的性质不成立来进行的,从而原假设是错误的

  #### 胁迫式证明(proof by intimidation)

  一种调侃的说法,指的是"显然"的却一般未必那么显然的证明方式 

  ## 空间复杂度

  程序所需要的空间

  - 指令空间
    - 编译后的程序指令所需要的存储空间
  - 数据空间
    - 常量和简单变量所需要的存储空间
    - 动态数组和动态类实例等动态对象所需要的空间
  - 环境栈空间
    - 用来保存暂停函数和方法在恢复运行时所需要的信息

## 时间复杂度

  ## 渐近记法

  ### ==大$O$记法==

  定义:  

  $T(n) = O(f(n))$:当且仅当存在常数$c > 0$和$n_0$,使得对于所有的$n \geqslant n_0$,有$T(n) \leqslant cf(n)$

  > 大$O$记法实际是函数的上界

  #### 重要结论

  **法则1:**  

  如果$T_1(N) = O(f(N))$且$T_2(N) = O(g(N))$,那么,   

  - $T_1(N) + T_2(N) = O(f(N) + g(N))$,可以简写成$O(max(f(N),g(N)))$  
  - $T_1(N) * T_2(N) = O(f(N) * g(N))$   

  **法则2:**   
  如果$T(N)$是一个$k$次多项式,则$T(N) = \Theta(N^K)$   

  **法则3:**   
  对任意常数$k$, $log^k_N = O(N)$.

  - 它告诉我们对数增长得非常缓慢   

  **补充**  

  - 在需要大$O$表示的任何分析结果中,各种简化都是可能发生的.低阶项一般可以被忽略,而常数因子也可以弃掉.    
    - 将常数或低阶项放进大$O$是非常坏的习惯.
      - $T(N)=O(2N^2)$或$T(N) = O(N^2 + N)$,正常情形下应是$T(N) = O(N^2)$    
  - 能够通过计算极限$lim_{N \to \infty }{\frac{f(N)}{g(N)}}$来确定两个函数$f(N)$和$g(N)$的相对增长率.必要的时候可以使用洛必达法则   
    - 极限是$0$:意味着$f(N)=o(g(N))$
    - 极限是$c \neq  0$:意味着$f(N)=\Theta(g(N))$
    - 极限是$\infty$:意味着$g(N) = o(f(N))$
    - 极限不存在:意味着二者无关
    - 一般两个函数之间的关系,通过简单的代数方法就可以得到  
      - 例如,$f(N)=Nlog(N)$和$g(N)=N^{0.5}$,那么为了确定两个函数哪个增长更快,实际上就是确定$Nlog(N)$和$N^{0.5}$哪个增长更快    
  - 风格上不要说成$f(N) \leqslant O(g(N)$,因为定义已经隐含有不等式了

  #### 各种$O$时间复杂度分析

  增长速度

  ==$c < logN < \sqrt N < {log}^2N < N < NlogN < N^2 < N^3 < 2^N < N!$==  

##### 高效解

  $c < logN$

  ###### 常数复杂度$O(1)$

  这类算法的效率最高

  不含转向(循环,调用,递归)

  ###### 对数复杂度$O(logN)$

  常数底数是可以忽略的

  - $\forall a,b > 0, log_an = log_ab \cdot log_bn = \Theta (log_bn)$(换底公式)
    - $lnn = lgn = log_{100}n = O(logn)$

  常数底数次幂是可以忽略的 

  - $logn$复杂度接近于常数  
    - $\forall c > 0, logn = O(n^c)$

  ##### 有效解

  $\sqrt N < {log}^2N < N < NlogN < N^2 < N^3 $

  ###### 线性复杂度$O(N)$

  ###### 多项式复杂度$O(n^c)$

  $100n + 200 = O(n)$ 
  $(100n - 500)(20n^2 - 300n + 2013) = O(n \times n^2) = O(n^3)$

  ##### 难解

  $ 2^N < N!$

  ###### 指数复杂度$O(a^n)$

  $n^c = O(2^n)$

  > 一般来说,很多问题都很容易找出指数复杂度的算法,而多项式却很难

  ### $\Omega$记法

  定义:

  $T(n) = \Omega(f(n))$:当且仅当存在常数$c > 0$和$n_0$,使得对于所有的$n \geqslant n_0$,有$T(n) \geqslant cf(n)$

  > $\Omega$记法实际是函数的下界

  ### $\Theta$记法

  定义:

  $T(n) = \Omega(f(n))$:当且仅当存在常数$c_1 > 0, c_2 > 0$和$n_0$,使得对于所有的$n \geqslant n_0$,有$ c_1f(n)\leqslant T(n) \leqslant c_2f(n)$

  ### 小 $o$记法

  - 如果对每一正常数$c$正常数$n_0$使得当$N > n_0$时,$T(N)<cp(N)$,则$T(N)=o(p(N))$. 
  - 也可简述为,如果$T(N)=O(p(N))$且$T(N) \neq \Theta(p(x))$,则$T(N)=o(p(N))$. 

  ## 封底估算(Back-Of-The-Envelop Calculation)

  只需要脑中的计算即可给出大致的估算结果  

  问题:估算地球的直径  

  抓住问题的主要方面  

  - 一天:$1 = 25 \times 60 \times 60 \approx 25 \times 4000 = 10^5 sec$
  - 一个世纪:$3 \times 10 ^ 9 sec$
  - 三个世界:$10 ^ {10}$
  - $2^{10} = 10^3$

  # 参考

  - 数据结构 邓俊辉  2013
  - 数据结构,算法与应用 C++语言描述 萨特吉 萨尼 2005
  - 数据结构与算法分析 C++描述 Mark Allen Weiss 2014