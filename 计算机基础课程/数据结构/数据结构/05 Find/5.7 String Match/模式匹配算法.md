# 模式匹配 
模式匹配算法(PMA(Pattern Matching Algorithm)):
- 已拥有一个文本串`s`,目标是将一个较短的模式串`p`与其匹配,判断是否是其子串,并找出位置

## 1. 朴素的模式匹配算法(The Most Straightforward Algorithm)

### 算法描述
设匹配到`i = m, j = n`:
- 将`s[i]`与`t[j]`进行比较
    - 若相等:`i`,`j`都向右移动一个位置
    - 若不相等:`i`回溯,`i = i - (j - 1)`,`j`重置为`0`

### 代码实现
```C++
bool MSA(const string &s, const string &p, int &pos) {
    int i = 0;
    int j = 0;
        /**************
     * Ls - Lp >= p中未匹配的字符,才能继续比较si与p0,否则s剩下的长度小于p剩下的长度比较下去,没有意义
     **************/
    while(i - j <= s.length() - p.length() && j < p.length()){
        if(s[i] == p[j]){
            i++;
            j++;
        }else{
            i = i - j + 1; // 从比较成功的字符位置后继续比较
            j = 0;
        }
    }

    if(j == p.length()){
        pos = static_cast<int>(i - p.length());
        return true;
    }

    return false;
}
```
### 时间复杂度分析
时间复杂度: `O(m \times n)`

效率低下的原因
- 当匹配失败时,`i`会回溯到本次匹配开始的位置,`j`重置为`0`  

## 2. 模式匹配的改进算法(KMP:Knuth–Morris–Pratt algorithm)
KMP的提出是为了解决以下问题  
- 利用已经部分匹配这个有效信息，保持`i`指针不回溯，通过修改`j`指针，让模式串尽量地移动到有效的位置
- 整个KMP的重点就在于当某一个字符与主串不匹配时，我们应该知道j指针要移动到下一个位置`k`(关键在于求这个位置`k`的值),然后继续比较

### 算法描述
- 假设现在文本串`s`匹配到`i`,模式串`t`匹配到`j`
    - 当`j = -1`或者`s[i] = t[j]`
        - 则进行`i++, j++`,继续匹配下一个字符
    - 当`j != -1`且`s[i] != t[j]`
        - 则令`i`不变,`j = next[j]`
            - 模式串`p`相对于文本串s向右移了$j - next[j] \geqslant 1$位
                - 即相当于用`t[next[j]]`与`s[i]`继续比较

说明`j - next[j]`  
```
i = `0123456789...`
s = `BBC ABCDAB ABCDABCDABDE`   
t = `    ABCDABD`
t = `        ABCDABD` // j - next[j] = 6 - 2
```
- 字符串`t`向右滑动`j - next[j] = 6 - 2`个位置,从而`s[i]`与`t[j]`继续比较
- 相当于将`j`赋值为`next[j]`,指针从位置`j`跳到`next[j]`

> KMP关键的,难以理解的就是`next[j]`  
> `j`为什么会可以等于`-1`,会在后面解释

### 代码
KMP部分
```C++
bool KMP(string s, string t, int pos){
    int i = 0;
    int j = 0;
    vector<int> next = getNext(t);

    while(i < s.length() && j < t.length()){
        if( j == -1 || s[i] == t[j]){
            i++;
            j++;
        }

        if( j != -1 && s[i] != t[j]){
            j = next[j];
        }
    }

    if(j == t.length()){
        pos = i - j;
        return true;
    } else{
        pos = -1;
        return false;
    }
}
```
- 当`j = -1`时，要移动的是`i`，当然`j`也要归`0`

`next`部分  
`next[j]`的作用
- 当某一次字符匹配`p[j]`失败了,该字符对应`next[j]`值,会返回`p`应该跳到哪个位置
```C++
vector<int> getNext(string t){
    vector<int> next(t.length(), 0);
    next[0] = -1;
    int k = -1; // 前缀
    int j = 0; // 后缀

    while(j < t.length()){
        if(k == -1 || t[j] == t[k]){
            next[j++] = ++k;
        }else{
            k = next[k];
        }
    }

    return next;
}
```
`next`代码的简单介绍
- `t[j] = t[k]`:
    - 说明从`0-k`长度的前缀有对应后缀与之相等，`next[j+1]=next[j]+1=k+1`
- `k=-1`:
    - 说明`k+1`指向模式串第一个字母，前缀为空，故`next[j+1]=0=-1+1=k+1`
- `t[j] != t[k]`:
    - k要回退到`next[k]`

> `next`代码的难以理解在于`t[j] != t[k]`时,`k`要回退到`next[k]`

### 分析为什么KMP优于MSA
首先引入几个概念
- 前缀字符串
- 后缀字符串
- 最大前缀后缀公共字符串长度(字符个数)
    - 若找到前缀后缀公共字符串,则
        - 前缀字符串
            - `t[0, k-1]`:以字符`t[0]`开始的到字符`t[k-1]`为止的字符串,长度为`k`
        - 后缀字符串
            - `t[j-k, j-1]`:以字符`t[j-k]`开始的到字符`t[j-1]`为止的字符串,长度为`k`
    - 最大前缀后缀公共字符串长度,取其中的最大`k`值

举例说明    
- `t = "abab"`  

 模式串 | a| b| a| b
---|---|---|---|---
 最大前缀后缀公共元素长度| 0| 0| 1| 2
 next| -1| 0| 0 | 1
 
 说明
 - 对于`"aba"`
    - 最大前缀后缀公共元素为`a`,长度为`1`
    - `next[3]`,即`t[3]`(字符`a`)之前的字符串`"ab"`中有长度为`0`的相同前缀后缀

为了解决朴素的模式匹配算法存在的问题,`next`需要满足,即为了使用KMP,当`s[i]`与`t[j]`匹配失败时,进行下一次匹配,即`s[i]`与`t[k]`的比较,`k`需要满足的条件
- 条件1:
    - `s[i-k, i-1] = t[j-k, j-1]`
    - 即`s[i]`之前的`k`个字符与`t[j]`之前的`k`个字符要相等
    - 即已经比较过了`i`前面的`k`个字符与`j`前面的`k`个字符,不需要`i`进行回溯,再进行比较
- 条件2:
    - `s[i-k, i-1] = t[0, k-1]`
        - 即`s[i]`之前的`k`个字符与`t[k]`之前的`k`个字符要相等
        - 即要找的新的`j`的值`k`,需要满足`t[0, k-1]`字符串与`s[i-k, i-1]`字符串相等,不需要`j`重置为`0`,再进行比较
- 由条件1和条件2得
    - `t[0, k-1] = t[j-k, j-1]`
    - 即`t[k]`之前的`k`个字符与`t[j]`之前的`k`个字符要相等
    - 即`k`值与`s`串无关,仅与目标串`t`有关

### 分析最大前缀后缀公共元素长度与`next`的关系
 模式串| A| B| C| D| A| B| D
---|---|---|---|---|---|---|---
 最大前缀后缀公共元素长度| 0| 0| 0| 0| 1| 2| 0

关于`j - next[j]`的公式
- `失配时,模式串向右移动的位数为 = 已匹配字符数 - 失配字符的上一位字符所对应的最大前缀后缀公共元素长度`
    - 因为模式串中前后缀可能会有重复的字符
    - 例如
        - `D`的前面的`ABCDAB`,前缀字符串`AB`与后缀字符串`AB`重复
- 比较之前:
    - 跳过`BBC `,即从`i = 4, j = 0`开始(很明显`s`的`BBC `与`t`的`A`不等,所以跳过)
```
i = `0123456789...`
s = `BBC ABCDAB ABCDABCDABDE`   
t = `ABCDABD`
```
```
i = `0123456789...`
s = `BBC ABCDAB ABCDABCDABDE`   
t = `    ABCDABD`
```
- 第1次滑动:
    - `s[4] = t[0]`,`i`与`j`
    - `i`与`j`均`+1`直到`s[10] != t[6]`
    - `6 - 2 = 4`,`t`继续向右移动4个位置长度
```
i = `0123456789...`
s = `BBC ABCDAB ABCDABCDABDE`   
t = `        ABCDABD` // 向右滑行4个位置,或指针j跳到2
```
- 第2次滑动:
    - `s[8] = t[2]`
    - `i`与`j`均`+1`直到`s[10] != t[2]`
    - `2 - 0 = 2`,`t`继续向右移动2个位置长度
```
i = `0123456789...`
s = `BBC ABCDAB ABCDABCDABDE`   
t = `          ABCDABD` 
```
- 第3次滑动:
    - `s[10] != t[0]`
    - 向右移动1
        - 这个没看懂是根据什么.是根据`j=0`,所以只能向右滑动?
```
i = `0123456789...`
s = `BBC ABCDAB ABCDABCDABDE`   
t = `           ABCDABD` 
```
- 第4次滑动:
    - `s[11] = t[0]`
    - `i`与`j`均`+1`直到`s[17] != t[6]`
    - `6 - 2 = 4`,`t`继续向右移动4个位置长度
```
i = `0123456789...`
s = `BBC ABCDAB ABCDABCDABDE`   
t = `               ABCDABD` 
```
- 匹配结束

#### 对比最大前缀后缀公共元素长度与`next`   
 模式串| A| B| C| D| A| B| D
---|---|---|---|---|---|---|---
 最大前缀后缀公共元素长度| 0| 0| 0| 0| 1| 2| 0
 next | -1| 0| 0| 0| 0| 1| 2

得到
- `next`相当于最大前缀后缀公共元素长度表右移一个个位置,然后空出的位置`0`d的对应元素赋值为`-1`

得到
- `失配时,模式串向右移动的位数为 = 失配字符所在位置 - 失配字符对应的next值`
    - `已匹配字符数 = 失配字符所在位置`
    - **失配字符的上一位字符所对应的最大前缀后缀公共元素长度 = 失配字符对应的next值**


### 关于`next[j]`的递推关系式
已知`next[j] = k`
- 即`t[0, k-1] = t[j-k, j-1]`,在`j`之前有
    - 可得,若`j`匹配失败,`t`向右移动的距离是`j - next[j]`

#### 如何根据`next[0, j]`求出`next[j + 1]`?
- 当`t[k] = t[j]`时
    - `next[j + 1] = next[j] + 1 = k + 1`
- 当`t[k] != t[j]`时
    - 相当于字符串`t[0,k]`与`t[j-k, j]`的匹配,只不过是按照以下模式匹配
        - 目的是在`t[0,k]`寻找以`t[j]`结尾的前缀字符串
        - 由于`t[k] != t[j]`找不到
        - 则需要在其他一个前缀和后缀相等的情况中,需找一个`t[0, k']`前缀串,然后判断`t[k']`与`t[j]`是否相等,若相等则`t[0,k'] = t[j-k', j]`,然后`next[j + 1] = next[j] + 1 = k' + 1`.
            - 而此处`t[0, k']`字符串的长度恰恰是`next[k]`的定义.也正是`k'`的值
    - 故`k = next[k]`

##### `t[k] = t[j]` 
 下标 | 0| 1| 2| 3| 4| 5| 6| 7
---|---|---|---|---|---|---|---|---
 索引 | 0| k-1| k| k+1| j-k| j-1| j| j+1
 模式串| A| B| C| D| A| B| C| E
 最大前缀后缀公共元素长度| 0| 0| 0 | 0| 1| 2| 3| 0
 next| -1| 0| 0| 0 | 0| 1| 2| ?
 
- t = "ABCDABCE"  
- 已知`next[j] = k`
    - 即`next[6] = 2`
    - 即`t[0, k-1] = t[j-k, j-1]`
    - 即`AB=AB`
- 求`next[j + 1]`
    - 因为`t[k] = t[j]=C`
    - 所以`next[j + 1] = next[j] + 1 = k + 1`

> `next[j]` = 失配字符`j`的上一位字符所对应的最大前缀后缀公共元素长度

##### `t[k] != t[j]`
下标 | 0| 1| 2| 3| 4| 5| 6| 7
---|---|---|---|---|---|---|---|---
 索引 | 0| k-1| k| k+1| j-k| j-1| j| j+1
 模式串| A| B| C| D| A| B| D| E
 最大前缀后缀公共元素长度| 0| 0| 0 | 0| 1| 2| 3| 0
 next| -1| 0| 0| 0 | 0| 1| 2| ?
 
 t = "ABCDABCE"  
- 已知`next[j] = k`
    - 即`next[6] = 2`
    - 即`t[0, k-1] = t[j-k, j-1]`
    - 即`AB=AB`
- 求`next[j + 1]`
    - 因为`t[k] != t[j]`
    - 所以`k' = next[k] = next[2] = 0`
        - `t[k'] != t[j]`:`t[k'] = t[2] = C`,`t[j] = t[6] = D`
        - 继续向前寻找`k = next[k'] = next[0] = -1`.至此找了所有的前缀字符串都没有找到以`t[j]`结尾的

    - 由于`k = -1`,所以`next[j + 1] = k + 1 = 0`

### `next`优化版

## 3. BM

## 4. Sunday

# 参考资料
- [详解KMP算法](https://www.cnblogs.com/yjiyjige/p/3263858.html)   
- [字符串模式匹配KMP算法中的next数组算法及C++实现](https://www.cnblogs.com/renjiashuo/p/6896062.html)
- [<C/C++算法>字符串匹配---KMP算法](https://blog.csdn.net/ebowtang/article/details/49129363)
- [从头到尾彻底理解KMP](https://blog.csdn.net/v_july_v/article/details/7041827)
- [超详细理解：kmp算法next数组求解过程和回溯的含义](https://blog.csdn.net/buppt/article/details/78531384)
- 数据结构C语言版,严蔚敏:P80,4.3.2,算法4.6
- [算法——KMP算法](https://blog.csdn.net/Tracy_frog/article/details/79608091)
- [编程小白眼中的KMP-----C++实现](https://blog.csdn.net/a1b2c3d4123456/article/details/50506454)