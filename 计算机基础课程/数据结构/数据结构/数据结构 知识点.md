# 数据结构 知识点

## 0. 绪论

数据的逻辑结构
  - 集合结构
    - 数据结构中的元素之间除了“同属一个集合” 的相互关系外，别无其他关系
  - 线性结构
    - 数据结构中的元素存在一对一的相互关系
  - 树状结构
    - 数据结构中的元素存在一对多的相互关系
  - 网(图)络结构
    - 数据结构中的元素存在多对多的相互关系

数据的存储结构
  - 顺序
  - 链接
  - 索引
  - 散列

## 时间复杂度

## 1. 线性表

### 线性表的定义和基本操作

### 线性表的实现
- 顺序存储
  - 计算多维数组某个元素的位置
- 链式存储
  - 链表删除,插入,查找元素的时间复杂度
- 线性表的应用

## 2. 栈,队列和数组

### 栈和队列的基本概念
栈
- 后进先出
- 给出一个序列,写出所有可能的输出序列

### 栈和队列的顺序存储

### 栈和队列的链式存储

### 栈和队列的应用

### 特殊矩阵的压缩存储

#### 矩阵

#### 特殊矩阵和稀疏矩阵

### 题目

## 3. 树与二叉树

### 树的基本概念

### 二叉树

#### 二叉树的定义及其主要特征
- 总分支数 = 总结点数 - 1
  - 不仅适用于二叉树
- 一个二叉树$T$有$n$个结点,其中叶子结点有$n_0$个,有两个子结点的结点个数为$n_2$,则有$n_0 = n_2 + 1$
  - 求二叉树的空指针数有多少
    - 将空指针看作叶子结点
    - 这样除了叶子结点,其他结点(原有的结点)都是双分支结点
- 二叉树,在$i$层数中的结点至多有$2^i$个
- 高度为$k$的二叉树中至多有$2^{k+1} - 1$个结点
- 一个非空高度为$k$的满二叉树,有$2^{k + 1} - 1$个结点

#### 完全二叉树
##### 完全二叉树定义
- 一颗包含$n$个结点高度为k的二叉树$T$
- 按层数顺序编号$T$的所有结点
- 对应于一棵高度为$k$的满二叉树中编号由$1$至$n$的结点

##### 完全二叉树的特点
- 树中只有最下两层结点的度可以小于$2$
- 树中最下一层的结点都集中在该层最左边的若干位置上
- 树中的叶结点只能在最大的两层上出现
  - 即存在一个非负整数$k$使得树中每个叶结点在第$k$层或第$k+1$层
- 对树中所有结点,按层数顺序,用自然数从$1$开始编号,仅仅编号最大的非叶结点可以没有右儿子,其余叶结点都有两个儿子结点
- 树中所有结点对应于高度为k的满二叉树中编号由$1$至$n$的那些结点
- 具有$n$个结点的完全二叉树的高度是$\left \lfloor log_2n \right \rfloor + 1$

若将一课有$n$个结点的完全二叉树按层次顺序用自然数从$1$开始编号,则编号为$i (1 \leqslant i \leqslant n$)的结点满足
- 若$i \neq1$  
  -  则编号为i的结点之父的编号为$\left \lfloor \frac{i}{2} \right \rfloor$
- 若$2i \leqslant n$
  - 则编号为$i$的结点的左儿子编号为$2i$, 否则$i$无左儿子
- 若$2i + 1 \leqslant  n$
  - 则编号为$i$的结点的右儿子编号为$2i + 1$,否则$i$无右儿子

#### 二叉树的顺序存储结构和链式存储结构

#### 二叉树的遍历

##### 先根遍历
- 递归:
  - 先访问根,然后遍历左子树,最后遍历右子树
- 非递归:
  - 判断栈是否为空或子树为空
  - 若不为空，就访问然后左孩子入栈，直至左孩子为空
  - 若左孩子为空，就出栈，然后访问右孩子，入栈，就这样不断的循环。

##### 中根遍历
- 递归:
    - 先遍历左子树,然后访问根,最后遍历右子树
- 非递归:(与非递归先跟遍历大致一样)
  - 判断栈是否为空或子树为空
  - 若为空，则出栈，输出数据，然后访问右子树。

##### 后根遍历
- 递归:
  - 先遍历左子树,然后遍历右子树,最后访问根
- 非递归
  - 要保证根结点在左孩子和右孩子访问之后才能访问
  - 因此对于任一结点`p`，先将其入栈。
    - 如果'p'不存在左孩子和右孩子，则可以直接访问它；或者P存在左孩子或者右孩子，但是其左孩子和右孩子都已被访问过了，则同样可以直接访问该结点。
  - 若非上述两种情况，则将P的右孩子和左孩子依次入栈，这样就保证了每次取栈顶元素的时候，左孩子在右孩子前面被访问，左孩子和右孩子都在根结点前面被访问。

##### 层次遍历
从第0层开始逐层向下,同层从左到右的次序访问二叉树的所有结点
具体算法
- 根节点入队
- 重复本步骤直到队列为空
  - 若队列非空,取队头结点并访问
  - 若其左指针不空,将其左儿子入队;若其右指针不空,将其右儿子入队

##### 小结
三种遍历方法的序列的叶结点的相对次序是相同的,叶结点都是从左到右的次序排列;
区别仅在于非叶结点间的次序以及非叶结点和叶结点的次序有所不同

举例:二叉树`AB#CD###EF###`
- 先根遍历:`ABCDEF`
- 中根遍历:`BDCAFE`
- 后根遍历:`DCBFEA`
- 层次遍历:`ABECFD`

#### 二叉表达式树

遍历`(a+b)*(c-d)-e`

- 先根遍历
  - 前缀表示法`-*+ab-cde`
- 中根遍历
  - 中缀表示法`a+b*c-d-e`
- 后根遍历
  - 后缀表示法`ab+cd-xe-`

==后缀表达式转换为表达式树(*)==

- 依次读取表达式
- 如果是操作数，则将该操作数压入栈中
- 如果是操作符，则弹出栈中的两个元素，
  - 第一个弹出的元素作为右孩子，
  - 第二个弹出的元素作为左孩子；
  - 然后再将该操作符压入栈中

中缀表达式转换成后缀表达式

#### 线索二叉树的基本概念和构造

### 树,森林

#### 树的存储结构

#### 树,森林与二叉树的转换

##### 树转为二叉树
- 树的孩子兄弟存储结构是基于二叉链表实现的
- 用二叉链表存储树
  - 结点指针
    - 一个指针指向孩子
    - 另一个指针指向自己的兄弟结点
- 森林与二叉树的转换
  - 将同一结点的各孩子结点用虚线串起来
  - 将每个结点的分支从左往右除了第一个以外,其余的都剪掉.即可得到二叉树
  - 调整结点使之符合二叉树的层次

##### 二叉树转为树
- 先将一颗二叉树分层,调整为水平方向
- 找到每一层结点在其上一层的父结点
- 将每一层的结点和其父结点相连,然后删除每一层结点之间的连接,得到树

##### 森林转为二叉树
将森林转为二叉树
- 将森林中的每棵树分别转化后得到的多颗二叉树按照规则连接成一颗二叉树
- 根据兄弟孩子表示法,树的根结点一定没有右兄弟的,所以可以将空出的指针连接森林其他树的根结点

##### 二叉树转为森林
- 将二叉树根结点的右孩子的链接不断断开,直到根结点不存在右孩子为止
- 得到多颗二叉树

### 树与二叉树的应用

#### 二叉排序树

##### 二叉排序树定义
二叉排序树定义
- 若二叉排序树的左子树不空,则左子树所有关键字均小于根关键字的值
- 若二叉排序树的右子树不空,则右子树所有关键字均大于根关键字的值
- 左右子树仍然是二叉排序树

> 由二叉排序树定义了解,若对其进行中序遍历,则这个序列为递增序列

##### 二叉排序树的操作

###### 查找关键字

###### 插入关键字

###### 构造二叉排序树

###### 删除关键字
在二叉排序树中删除一个关键字,不能将关键字所在结点为根的子树都删除,而是只删除这一个结点,并保持二叉排序树的特性

假设删除结点 `p`,其父亲为`f`
- 第一种情况:`p`为叶子结点.直接删除
- 第二种情况: `p`只有右子树,没有左子树;或者只有左子树,没有右子树
	- 此时,直接删除`p`,然后将`p`的子树直接连接在原来`p`与其父亲结点`f`连接的指针上即可
- 第三种情况:`p`既有左子树,又有右子树
	- 可以转化为第一,二中情况
	- 方式1:沿着`p`的左子树根结点的右指针一直往右走,直到来到其右子树的最右边的一个结点`r`
	- 方式2:沿着`p`的右子树根结点的左指针一直往左走,直到来到其左子树的最左边的一个结点`l`
	- 将`p`中的关键字用`r`(或`l`)中的关键字代替
	- 判断
		- 如果是叶子结点,执行第一种情况
		- 如果不是叶子结点,执行第二种情况
			- 此时`r`(或`l`)不可能有两个子结点
				- 原因:
	- 删除结点`r`(或`l`)

####  平衡二叉树(AVL树)

##### 平衡二叉树的定义
平衡二叉树是一种特殊的,改进版的二叉排序树

引入平衡因子
- 平衡因子是针对树中的结点来说的
- 一个结点的平衡因子等于其左子树的高度减去右子树的高度差
- 平衡因子的取值为`-1, 0, 1`

##### 平衡二叉树的建立
- 平衡二叉树的建立与二叉排序树的建立过程基本一致
- 区别是在将关键字插入时,需要检查看是否破坏了原有的平衡,
	- 即树中出现平衡因子大于`1`的结点
- 如果破坏了平衡,需要平衡调整

##### 平衡调整
- 假定向二叉平衡树插入一个新结点后,破坏了平衡二叉树的平衡性
- 首先,要找出插入新结点后失去平衡的二叉树,然后再调整这棵子树,使之称为平衡树
- 当失去平衡的最小子树被调整为平衡子树后,无需调整原有其他所有的不平衡树,整个二叉排序树就会称为一课平衡二叉树
	- 失去平衡的最小子树(最小不平衡树)
		- 以距离插入结点最近,且以平衡因子绝对值大于1的结点作为根的子树

###### 有四种情况的平衡调整
平衡调整必须保持排序二叉树左小右大的性质
`LL`(右单旋调整)
- 新插入结点落在最小不平衡树的左(`L`)的孩子的左(`L`)子树上
`RR`(左单旋调整)
- 新插入结点落在最小不平衡树的右(`R`)的孩子的右(`R`)子树上
`LR`(先左后右双旋转调整)
- 新插入结点落在最小不平衡树的左(`L`)孩子的的右(`R`)子树上
`RL`(先右后左双旋转调整)
- 新插入结点落在最小不平衡树的右(`R`)孩子的的左(`L`)子树上

####  哈夫曼树和哈夫曼编码
##### 哈夫曼树
###### 概念
带权路径长度
- 结点具有权值,从该结点到根之间的路径长度乘以结点的权值
树的带权路径长度(WPL)
- 树的带权路径长度是指树中所有叶子结点的带权路径长度之和

###### 哈夫曼树的构造
给定n个权值
- 将这n个权值分别看作只有根结点的n课二叉树,这n课二叉树记为集合F
- 从F中选择根结点的权值最小的树(假设为a,b)作为左,右子树,构造一颗新的二叉树(假设为c),新的二叉树根结点的权值为左右子树根结点权值之和
- 从F中删除a,b,加入新构造的c
- 重复2),3)过程,知道F中剩下一棵树为止,这棵树即为哈夫曼树

###### 哈夫曼树的特点
- 权值越大的结点,距离根结点越近
- 树中没有度为1的结点.这类树又叫作正则(严格)二叉树
- 树的带权路径长度最短

##### 哈夫曼编码
利用哈夫曼树的特点,进行哈夫曼编码,从而进行存储
原理
- 哈夫曼编码过程中,每个字符的权值是在字符串中出现的次数,路径长度即为每个字符编码的长度,出现次数越多的字符编码长度越短,因此使得其整个字符串被编码后的前缀码长度最短
- 即,哈夫曼编码产生的是最短前缀码

## 4. 图

### 图的基本概念
- 图
- 有向图和无向图
- 弧
- 边：弧和边
- 顶点的度，入度和出度
  - 顶点的度：与顶点相关的边的条数
- 有向完全图和无向完全图
- 路径和路径长度
- 简单路径
  - 序列中顶点不重复的路径
- 回路
  - 一条路径的起点和重点是同一个顶点
- 连通，连通图和联通分量
  - 连通
    - 两个顶点之间存在单向路径
  - 连通图
    - 图的任意两点之间都连通
  - 连通分量
    - 若图不是连通图，则该图的极大连通子图被称为连通分量
- 强连通图和强连通分量
  - 强连通图
    - 图的任意两点之间都是双向路径的强连通
  - 强连通分量
    - 若图不是强连通图，则该图的极大强连通子图被称为强连通分量
- 权和网

### 图的存储及基本操作

#### ==邻接矩阵法(*)==

邻接矩阵法
- 表示顶点之间相邻关系的矩阵
- 具体方法
  - 将顶点编号
  - $A[i][j] = 1$:表示$i$到$j$有边连接
  - $A[i][j] = 0$:表示$i$到$j$没有有边连接

带权图
- 若$A[i][j] = a$：表示带权的边,$i$到$j$有边,且权值为$a$
- 若$A[i][j] = \infty$或者$A[i][j] = 0$：表示$i$到$j$没有边,设权值为$\infty$或$0$
> $0 \leqslant  ij \leqslant n-1$,$n$为顶点数

#### 邻接表法

邻接表法
- 链式存储结构
- 具体方法
  - 对图中的每个顶点$i$建立一个单链表，每个单链表的第一个结点存放有关顶点的信息，把这一结点看作链表的表头，其余结点存放有关边的信息
  - 邻接表 = 单链表的表头形成的顶点表 + 单链表其余结点形成的边表两部分组成
    - 一般顶点表存放顶点信息和指向第一个边结点指针
    - 边表结点存放当前结点相邻接顶点的序号和指向下一边结点的指针

#### 邻接多重表,十字链表

##### 邻接多重表
邻接多重表
- 由顶点表和边表组成，每一条边用一个结点表示
	- 顶点表结构：$vertex ,firstedge$
		- `vertex`：存储和该顶点信息相关的域
		- `firstedge`：指示第一条附于该顶点的边
	- 边表结构：$mark,ivex,ilink,jvex,jlink,info$
		- `mark`：标记域，可以用来标记该条边是否被搜索过
		- `ivex`和`jvex`：该边依附的两个顶点在图中位置
		- `ilink`：指向下一条依附于顶点`ivex`的边
		- `jlink`：指向下一条依附于顶点`jvex`的边
		- `info`：为指向与边相关的各种信息的指针域

### 图的遍历

#### 深度优先遍历
深度优先遍历
- 类似于二叉树的先序遍历
- 基本思想
	- 首先访问出发点`v`,并将其标记为已访问过
	- 然后选取与`v`邻接的未被访问的任意一个顶点`w`,并访问它
	- 再选取与`w`邻接的未被访问的任一顶点并访问,以此重复
	- 当一个顶点所有邻接顶点都被访问过时则依次退回到最近被访问过的顶点,若该顶点还有其他邻接顶点未被访问,则从这些未被访问的顶点中取一个并重复上述过程,直至图中所有顶点都被访问过为止

#### 广度优先遍历
广度优先遍历
- 类似于树的层次遍历
- 基本思想
	- 首先访问起始顶点`v`,然后选取与`v`邻接的全部顶点$w_1, w_2, \cdots , w_n$进行访问
	- 再依次访问$w_1, w_2, \cdots , w_n$邻接的全部顶点(已经访问过的除外)
	- 以此类推,直到所有顶点都被访问过为止

### 图的基本应用

#### 最小(代价)生成树

##### 普里姆算法(Prim算法)
思想
- 从图中任意取出一个顶点,把它当做一棵树,然后从与这棵树相接的边中选取一条最短(权值最小)的边,并将这条边及其连接的顶点也并入这棵树,此时得到了一颗有两个顶点的树
- 然后从与这颗树相接的边中选取一条最短的边,并将这条边及其所连顶点并入当前树中,得到一颗有3个顶点的树
- 以此类推,直到图中所有顶点都被并入树中为止,此时得到的生成树就是最小生成树

执行过程

算法代码

时间复杂度分析
- $O(n^2)$
- 适用于稠密图
	- 时间复杂度只与图中顶点有关系

##### 克鲁斯卡尔算法(Kruskal算法)
思想
- 每次找出候选边中权值最小的边,就将该边并入生成树中,重复此过程直到所有边都被检测完为止

执行过程

算法代码

时间复杂度分析
- 一般大于常量级
- 适用于稀疏图
	- 主要与图的边数有关,与顶点数无关

#### 最短路径

##### 迪杰斯特拉算法(Dijkstra算法)
思想
- 设有两个顶点集合S和T
  - 集合S中存放图中已经找到最短路径的顶点
  - 集合T存放图中剩余顶点
- 初始状态
  - 集合S中值包含源点$v_0$
- 然后不断从集合T中选取到顶点$v_0$路径长度最短的顶点$v_u$并入到集合$S$中
- 集合S没并入一个新的顶点$v_u$,都要修改$v_0$到集合T中顶点的最短路径长度值
- 不断重复此过程,直到集合T中的顶点全部并入到S为止

执行过程

算法代码

时间复杂度分析

##### 弗洛伊德算法(Floyd算法)
求图中任意一对顶点间的最短路径

思想
- 设置两个矩阵A和Path,初始时将图的邻接矩阵赋值给A,将矩阵Path中元素全部设置为-1
- 以顶点k为中间顶点,$k \in [0,n-1]$(n为顶点数),对图中所有顶点对${i,j}$进行如下检测与修改
- 如果$A[i][j] > A[i][k] + A[k][j]$,则将$A[i][j]$改为$A[i][k]+A[k][j]$的值,将$Path[i][j]$改为k,否则什么都不做

执行过程

算法代码

时间复杂度分析

#### 拓扑排序

##### AOV网

AOV网
- 以顶点表示活动
- 以边表示活动的先后次序
- 没有回路的有向图
- 用于表示整个工程中各个活动之间的先后关系的有向图

##### ==拓扑排序的核心算法(*)==

对一个有向无环图G进行拓扑排序,是将G中所有顶点排成一个线性序列,使得图中任意一对顶点u和v,若存在由u到v的路径,则在拓扑排序序列中一定是u出现在v的前边


在一个有向图中寻找一个拓扑排序序列的过程
- 第一步: 从有向图中选择一个没有前驱(入度为0)的顶点输出
- 第二步: 删除第一步中的顶点,并且删除从该顶点出发的全部边
- 重复上述过程,直到剩余的图中不存在没有前驱的顶点为止

#### 关键路径

##### AOE网

- 以顶点表示事件

  - 事件是图中新活动开始或就活动结束的标志

- 以边有权值,表示活动持续时间

- 没有回路的有向图


##### 关键路径核心算法

关键路径

- AOE网中,从源点到汇点的所有路径中,具有最大路径长度的路径

算法

- 首先求出事件的最早发生时间
  - 事件的最早发生时间:从源点到顶点$k$的路径中的最长者
  - $ve(k) = max\{ve(j) +<j,k>\}$
    - $j$为$k$的前驱事件,可能有多个,选取其中的最大者

## 5. 查找

### 查找的基本概念
通常将查找过程中对关键字的平均比较次数最为衡量一个查找算法效率优劣的标准

### 顺序查找法
思想
- 从表的一端开始,顺序扫描线性表,一次将扫描到的关键字与给定值k比较
- 若当前扫描的关键字与k值相等,则查找成功
- 若扫描结束后,仍未发现关键字等于k的记录,则查找失败

### 分块查找法(索引顺序查找)
思想
- 分块查找将线性表分为若干块
- 每一块中的元素存储顺序是任意的,但是块与块之间必须按照关键字大小有序排列
  - 即前一块的最大关键字要小于后一块的最大关键字
- 需要对顺序表额外建立一个索引表,键值存放对应块的最大关键字
  - 键值分量存放指向本块第一个元素和最后一个元素的指针
  - 显然索引表中的所有索引都是按照其关键字递增的顺序排列的

算法描述
  - 第一步: 确定带查找的元素属于哪一块
    - 二分查找
  - 第二步: 在块内精确查找
    - 顺序查找

### 折半查找法
思想
- 要求线性表是有序的,即表中记录的关键字是有序的
- 折半查找可以用二叉树来表示,称为折半查找的判定树
  - 左子表对用左子树.右子表对应右子树
  - 叶子结点代表查找失败的位置
  - 折半查找的比较次数为从根结点到待查找元素所经过的结点数
  - 算法时间复杂度用树的高度表示$log_2n$

### $B-$($B$)树及其基本操作,$B+$树的基本概念

#### $B-$($B$)树及其基本操作

##### $B-$树的基本概念
$B-$是一种平衡多叉树

$B-$树的阶$m \geqslant  3$
- $B-$树中所有结点孩子结点个数的最大值

一棵$m$阶的$B-$树或者是一棵空树,或者是满足以下性质的$m$叉树
第一点
- 每个结点最多有$m$个分支(子树)
- 最少分支数要看是否为根结点
  - 如果是根结点且不是叶子结点,则至少有两个分支
  - 非根非叶结点至少有$\left \lceil m \right \rceil$个分支

第二点
- 有$n \in [k,n]$个分支的结点有$n-1$个关键字它们按递增顺序排序
  - $k = 2$为根结点
  - $k = \left \lceil m \right \rceil$非根结点

第三点
- 每个结点的结构
  | $n$   | $k_1$ | $k_2$ | $\cdots$ | $k_n$ |
  | ----- | ----- | ----- | -------- | ----- |
  | $p_0$ | $p_1$ | $p_2$ | $\cdots$ | $p_n$ |
  - $n$为该结点中关键字的个数
  - $k_i ,i \in [1,n]$为该结点的关键字
    - 且满足$k_i < k_{i+1}$
  - $p_i, i \in [1,n]$为该结点的孩子结点指针
    - 且满足$p_i,i \in [1,n-1]$所指结点上的关键字大于$k_i$且小于$k_{i+1}$
    - $p_0$上所指结点上的关键字小于$k_1$
    - $p_n$上所指结点上的关键字大于$k_0$

第四点
- 结点内关键字互不相等且按从小到大排列

第五点
- 叶结点处于同一层
  - 可以用空指针表示,是查找失败到达的位置

##### $B-$的基本操作

###### $B-$树关键字查找
$B-$树关键字查找
- $B-$树关键字的查找是二叉排序树的扩展,即多路查找
- 结点内查找
	- 由于结点内是有序的,所以可以在结点内用顺序查找或折半查找

具体查找步骤

###### $B-$树关键字的插入和删除

#### $B+$树的基本概念
$B+$树与$B-$树的区别
第一点
- 在$B+$树中,具有$n$个关键字的结点含有$n$个分支
- 在$B-$树中,具有$n$个关键字的结点含有$n + 1$个分支

第二点
- 在$B+$树中
  - 每个结点(根结点除外)中的关键字的个数$n \in [\left \lceil \frac{m}{2} \right \rceil, m]$
    - 根结点的取值范围$n \in [2,m]$
  - 在$B-$树中
    - 每个结点(根结点除外)中的关键字的个数$n \in [\left \lceil \frac{m}{2} \right \rceil - 1, m - 1]$
    - 根结点的取值范围$n \in [1,m-1]$

第三点
- 在$B+$树中叶子结点包含信息,并且包含了全部关键字,叶子结点引出的指针指向记录(此处关键字和记录要区分开)

第四点
- 在$B+$树中的所有非叶结点仅起到一个索引的作用
  - 即结点中每个索引都只含有对应子树的最大关键字和指向该子树的指针,不含有该关键字对应记录的存储地址
  - 在$B-$树中,每个关键字对应一个记录的存储地址

第五点
- 在$B+$树上有一个指针指向关键字最小的叶子结点,所有叶子结点链接成一个线性链表
- 在$B-$树没有

### 散列表

#### 散列表的概念
根据给定的关键字来计算出关键字在表中的地址

#### 散列表的建立方法以及冲突解决方法

#### 散列表的性能分析

### 字符串匹配模式

#### 朴素的模式匹配算法
参考资料
- [详解KMP算法](https://www.cnblogs.com/yjiyjige/p/3263858.html)   
- [字符串模式匹配KMP算法中的next数组算法及C++实现](https://www.cnblogs.com/renjiashuo/p/6896062.html)
- [<C/C++算法>字符串匹配---KMP算法](https://blog.csdn.net/ebowtang/article/details/49129363)
- [从头到尾彻底理解KMP](https://blog.csdn.net/v_july_v/article/details/7041827)
- [超详细理解：kmp算法next数组求解过程和回溯的含义](https://blog.csdn.net/buppt/article/details/78531384)
- 数据结构C语言版,严蔚敏:P80,4.3.2,算法4.6
- [算法——KMP算法](https://blog.csdn.net/Tracy_frog/article/details/79608091)
- [编程小白眼中的KMP-----C++实现](https://blog.csdn.net/a1b2c3d4123456/article/details/50506454)

##### 算法描述
设匹配到`i = m, j = n`:
- 将`s[i]`与`t[j]`进行比较
    - 若相等:`i`,`j`都向右移动一个位置
    - 若不相等:`i`回溯,`i = i - (j - 1)`,`j`重置为`0`

##### 代码实现
```C++
bool MSA(const string &s, const string &p, int &pos) {
    int i = 0;
    int j = 0;
        /**************
     * Ls - Lp >= p中未匹配的字符,才能继续比较si与p0,否则s剩下的长度小于p剩下的长度比较下去,没有意义
     **************/
    while(i - j <= s.length() - p.length() && j < p.length()){
        if(s[i] == p[j]){
            i++;
            j++;
        }else{
            i = i - j + 1; // 从比较成功的字符位置后继续比较
            j = 0;
        }
    }

    if(j == p.length()){
        pos = static_cast<int>(i - p.length());
        return true;
    }

    return false;
}
```
##### 时间复杂度分析
时间复杂度: `O(m \times n)`

效率低下的原因

- 当匹配失败时,`i`会回溯到本次匹配开始的位置,`j`重置为`0`  

#### 模式匹配的改进算法(KMP)
KMP的提出是为了解决以下问题  
- 利用已经部分匹配这个有效信息，保持`i`指针不回溯，通过修改`j`指针，让模式串尽量地移动到有效的位置
- 整个KMP的重点就在于当某一个字符与主串不匹配时，我们应该知道j指针要移动到下一个位置`k`(关键在于求这个位置`k`的值),然后继续比较

##### 算法描述
- 假设现在文本串`s`匹配到`i`,模式串`t`匹配到`j`
    - 当`j = -1`或者`s[i] = t[j]`
        - 则进行`i++, j++`,继续匹配下一个字符
    - 当`j != -1`且`s[i] != t[j]`
        - 则令`i`不变,`j = next[j]`
            - 模式串`p`相对于文本串s向右移了$j - next[j] \geqslant 1$位
                - 即相当于用`t[next[j]]`与`s[i]`继续比较

说明`j - next[j]`  
```
i = `0123456789...`
s = `BBC ABCDAB ABCDABCDABDE`   
t = `    ABCDABD`
t = `        ABCDABD` // j - next[j] = 6 - 2
```
- 字符串`t`向右滑动`j - next[j] = 6 - 2`个位置,从而`s[i]`与`t[j]`继续比较
- 相当于将`j`赋值为`next[j]`,指针从位置`j`跳到`next[j]`

> KMP关键的,难以理解的就是`next[j]`  
> `j`为什么会可以等于`-1`,会在后面解释

##### 代码
KMP部分
```C++
bool KMP(string s, string t, int pos){
    int i = 0;
    int j = 0;
    vector<int> next = getNext(t);

    while(i < s.length() && j < t.length()){
        if( j == -1 || s[i] == t[j]){
            i++;
            j++;
        }

        if( j != -1 && s[i] != t[j]){
            j = next[j];
        }
    }

    if(j == t.length()){
        pos = i - j;
        return true;
    } else{
        pos = -1;
        return false;
    }
}
```
- 当`j = -1`时，要移动的是`i`，当然`j`也要归`0`

`next`部分  
`next[j]`的作用
- 当某一次字符匹配`p[j]`失败了,该字符对应`next[j]`值,会返回`p`应该跳到哪个位置
```C++
vector<int> getNext(string t){
    vector<int> next(t.length(), 0);
    next[0] = -1;
    int k = -1; // 前缀
    int j = 0; // 后缀

    while(j < t.length()){
        if(k == -1 || t[j] == t[k]){
            next[j++] = ++k;
        }else{
            k = next[k];
        }
    }

    return next;
}
```
`next`代码的简单介绍
- `t[j] = t[k]`:
    - 说明从`0-k`长度的前缀有对应后缀与之相等，`next[j+1]=next[j]+1=k+1`
- `k=-1`:
    - 说明`k+1`指向模式串第一个字母，前缀为空，故`next[j+1]=0=-1+1=k+1`
- `t[j] != t[k]`:
    - k要回退到`next[k]`

> `next`代码的难以理解在于`t[j] != t[k]`时,`k`要回退到`next[k]`

##### 分析为什么KMP优于MSA
首先引入几个概念
- 前缀字符串
- 后缀字符串
- 最大前缀后缀公共字符串长度(字符个数)
    - 若找到前缀后缀公共字符串,则
        - 前缀字符串
            - `t[0, k-1]`:以字符`t[0]`开始的到字符`t[k-1]`为止的字符串,长度为`k`
        - 后缀字符串
            - `t[j-k, j-1]`:以字符`t[j-k]`开始的到字符`t[j-1]`为止的字符串,长度为`k`
    - 最大前缀后缀公共字符串长度,取其中的最大`k`值

举例说明    
- `t = "abab"`  

 模式串 | a| b| a| b
---|---|---|---|---
 最大前缀后缀公共元素长度| 0| 0| 1| 2
 next| -1| 0| 0 | 1

 说明
 - 对于`"aba"`
    - 最大前缀后缀公共元素为`a`,长度为`1`
    - `next[3]`,即`t[3]`(字符`a`)之前的字符串`"ab"`中有长度为`0`的相同前缀后缀

为了解决朴素的模式匹配算法存在的问题,`next`需要满足,即为了使用KMP,当`s[i]`与`t[j]`匹配失败时,进行下一次匹配,即`s[i]`与`t[k]`的比较,`k`需要满足的条件
- 条件1:
    - `s[i-k, i-1] = t[j-k, j-1]`
    - 即`s[i]`之前的`k`个字符与`t[j]`之前的`k`个字符要相等
    - 即已经比较过了`i`前面的`k`个字符与`j`前面的`k`个字符,不需要`i`进行回溯,再进行比较
- 条件2:
    - `s[i-k, i-1] = t[0, k-1]`
        - 即`s[i]`之前的`k`个字符与`t[k]`之前的`k`个字符要相等
        - 即要找的新的`j`的值`k`,需要满足`t[0, k-1]`字符串与`s[i-k, i-1]`字符串相等,不需要`j`重置为`0`,再进行比较
- 由条件1和条件2得
    - `t[0, k-1] = t[j-k, j-1]`
    - 即`t[k]`之前的`k`个字符与`t[j]`之前的`k`个字符要相等
    - 即`k`值与`s`串无关,仅与目标串`t`有关

##### 分析最大前缀后缀公共元素长度与`next`的关系
 模式串| A| B| C| D| A| B| D
---|---|---|---|---|---|---|---
 最大前缀后缀公共元素长度| 0| 0| 0| 0| 1| 2| 0

关于`j - next[j]`的公式
- `失配时,模式串向右移动的位数为 = 已匹配字符数 - 失配字符的上一位字符所对应的最大前缀后缀公共元素长度`
    - 因为模式串中前后缀可能会有重复的字符
    - 例如
        - `D`的前面的`ABCDAB`,前缀字符串`AB`与后缀字符串`AB`重复
- 比较之前:
    - 跳过`BBC `,即从`i = 4, j = 0`开始(很明显`s`的`BBC `与`t`的`A`不等,所以跳过)
```
i = `0123456789...`
s = `BBC ABCDAB ABCDABCDABDE`   
t = `ABCDABD`
```
```
i = `0123456789...`
s = `BBC ABCDAB ABCDABCDABDE`   
t = `    ABCDABD`
```
- 第1次滑动:
    - `s[4] = t[0]`,`i`与`j`
    - `i`与`j`均`+1`直到`s[10] != t[6]`
    - `6 - 2 = 4`,`t`继续向右移动4个位置长度
```
i = `0123456789...`
s = `BBC ABCDAB ABCDABCDABDE`   
t = `        ABCDABD` // 向右滑行4个位置,或指针j跳到2
```
- 第2次滑动:
    - `s[8] = t[2]`
    - `i`与`j`均`+1`直到`s[10] != t[2]`
    - `2 - 0 = 2`,`t`继续向右移动2个位置长度
```
i = `0123456789...`
s = `BBC ABCDAB ABCDABCDABDE`   
t = `          ABCDABD` 
```
- 第3次滑动:
    - `s[10] != t[0]`
    - 向右移动1
        - 这个没看懂是根据什么.是根据`j=0`,所以只能向右滑动?
```
i = `0123456789...`
s = `BBC ABCDAB ABCDABCDABDE`   
t = `           ABCDABD` 
```
- 第4次滑动:
    - `s[11] = t[0]`
    - `i`与`j`均`+1`直到`s[17] != t[6]`
    - `6 - 2 = 4`,`t`继续向右移动4个位置长度
```
i = `0123456789...`
s = `BBC ABCDAB ABCDABCDABDE`   
t = `               ABCDABD` 
```
- 匹配结束

###### 对比最大前缀后缀公共元素长度与`next`   
 模式串| A| B| C| D| A| B| D
---|---|---|---|---|---|---|---
 最大前缀后缀公共元素长度| 0| 0| 0| 0| 1| 2| 0
 next | -1| 0| 0| 0| 0| 1| 2

得到
- `next`相当于最大前缀后缀公共元素长度表右移一个个位置,然后空出的位置`0`d的对应元素赋值为`-1`

得到
- `失配时,模式串向右移动的位数为 = 失配字符所在位置 - 失配字符对应的next值`
    - `已匹配字符数 = 失配字符所在位置`
    - **失配字符的上一位字符所对应的最大前缀后缀公共元素长度 = 失配字符对应的next值**


##### 关于`next[j]`的递推关系式
已知`next[j] = k`
- 即`t[0, k-1] = t[j-k, j-1]`,在`j`之前有
    - 可得,若`j`匹配失败,`t`向右移动的距离是`j - next[j]`

###### 如何根据`next[0, j]`求出`next[j + 1]`?
- 当`t[k] = t[j]`时
    - `next[j + 1] = next[j] + 1 = k + 1`
- 当`t[k] != t[j]`时
    - 相当于字符串`t[0,k]`与`t[j-k, j]`的匹配,只不过是按照以下模式匹配
        - 目的是在`t[0,k]`寻找以`t[j]`结尾的前缀字符串
        - 由于`t[k] != t[j]`找不到
        - 则需要在其他一个前缀和后缀相等的情况中,需找一个`t[0, k']`前缀串,然后判断`t[k']`与`t[j]`是否相等,若相等则`t[0,k'] = t[j-k', j]`,然后`next[j + 1] = next[j] + 1 = k' + 1`.
            - 而此处`t[0, k']`字符串的长度恰恰是`next[k]`的定义.也正是`k'`的值
    - 故`k = next[k]`

###### 当 `t[k] = t[j]`

 下标 | 0| 1| 2| 3| 4| 5| 6| 7
---|---|---|---|---|---|---|---|---
 索引 | 0| k-1| k| k+1| j-k| j-1| j| j+1
 模式串| A| B| C| D| A| B| C| E
 最大前缀后缀公共元素长度| 0| 0| 0 | 0| 1| 2| 3| 0
 next| -1| 0| 0| 0 | 0| 1| 2| ?

- t = "ABCDABCE"  
- 已知`next[j] = k`
    - 即`next[6] = 2`
    - 即`t[0, k-1] = t[j-k, j-1]`
    - 即`AB=AB`
- 求`next[j + 1]`
    - 因为`t[k] = t[j]=C`
    - 所以`next[j + 1] = next[j] + 1 = k + 1`

> `next[j]` = 失配字符`j`的上一位字符所对应的最大前缀后缀公共元素长度

###### 当 `t[k] != t[j]`

下标 | 0| 1| 2| 3| 4| 5| 6| 7
---|---|---|---|---|---|---|---|---
 索引 | 0| k-1| k| k+1| j-k| j-1| j| j+1
 模式串| A| B| C| D| A| B| D| E
 最大前缀后缀公共元素长度| 0| 0| 0 | 0| 1| 2| 3| 0
 next| -1| 0| 0| 0 | 0| 1| 2| ?

 t = "ABCDABCE"  
- 已知`next[j] = k`
    - 即`next[6] = 2`
    - 即`t[0, k-1] = t[j-k, j-1]`
    - 即`AB=AB`
- 求`next[j + 1]`
    - 因为`t[k] != t[j]`
    - 所以`k' = next[k] = next[2] = 0`
        - `t[k'] != t[j]`:`t[k'] = t[2] = C`,`t[j] = t[6] = D`
        - 继续向前寻找`k = next[k'] = next[0] = -1`.至此找了所有的前缀字符串都没有找到以`t[j]`结尾的

    - 由于`k = -1`,所以`next[j + 1] = k + 1 = 0`

##### `next`优化版

### 查找算法的分析及应用

## 6. 排序

### 排序的基本概念
稳定性
- 当待排序列中有两个或两个以上相同的关键字时,排序前和排序后这些关键字的相对位置,如果没有发生变化就是稳定的,否则就是不稳定的

排序算法的分类
- 插入排序
  - 直接插入排序
  - 折半插入排序
  - 希尔排序
- 交换类排序
  - 起泡排序
  - 快速排序
- 选择类的排序
  - 简单选择排序
  - 堆排序
- 归并类的排序
  - 二路归并排序
- 基数类排序
  - 多关键字排序

### 插入排序

#### 直接插入排序
思想
- 每趟将一个带排序的关键字按照其值的大小插入到已经排好的部分有序序列的适当位置上,直到所有待排关键字都被插入到有序序列中为止

执行过程

代码

时间复杂度

#### 折半插入排序
思想
- 前提是要插入的序列已经是有序序列
- 采用折半查找法来查找插入位置

执行过程

代码

时间复杂度

#### 希尔排序(缩小增量排序)
思想
- 将待排序序列按某种规则分成几个子序列,分别对这几个子序列进行直接插入排序
- 规则
	- 增量的选取
		- 如果选增量为1,则就是直接插入排序

执行过程

代码

时间复杂度

### 交换类排序

#### 起泡排序(冒泡排序)
思想
- 首先第一个关键字和第二个关键字比较
  - 如果第一个关键字大,则二者交换
  - 否则不交换
- 然后比较第二个关键字和第三个关键字
  - 如果第二个关键字大,则二者交换
  - 否则不交换
- 一直按照这种方式执行下去,直到最终最大的关键字被交换到了最后
- 进过多躺这样的排序,最终整个序列有序

执行过程

代码

时间复杂度

#### 快速排序
思想
- 通过多次划分操作实现排序
- 以升序为例
  - 每一趟选择当前所有子序列中的第一个关键字作为枢轴
    - 将子序列中比枢轴小的移到枢轴前面
    - 将子序列中比枢轴大的移到枢轴后面
  - 当本趟所有子序列都被枢轴以上述规则划分完毕后会得到新的一组更短的子序列,它们称为下一趟划分的初始序列集

执行过程

代码

时间复杂度

### 选择类的排序

#### 简单选择排序
思想
- 从头至尾顺序扫描序列,找到最小的一个关键字,和第一个关键字交换,接着从剩下的关键字中继续这种选择和交换,最终使序列有序

执行过程

代码

时间复杂度

#### 堆排序
堆
- 可以看做一颗完全二叉树
- 任何一个非叶结点的值都不大于(不小于)其左右孩子结点的值
- 若父亲大孩子小,则被称为大堆
- 若父亲小孩子大,则被称为小堆

思想
- 由堆的定义知道,这课二叉树的根结点的值是最大值或最小值
- 将一个无序序列调整为一个堆,就可以找到这个序列的最大(小)值,然后将找出的这个值交换到序列的最后(或最前),这样有序序列增加1,无序序列减少1,对新的无序列重复这样的操作,就实现了排序
- 关键的操作
  - 将序列调整为堆
  - 整个排序过程就是不断调整,使得不符合堆定义的完全二叉树变为符合堆定义的完全二叉树

执行过程

代码

时间复杂度

### 归并类的排序

### 二路归并排序
思想
- 二路归并排序是一个分而治之的思想
- 先将整个序列分为两半,对每一半分别进行归并排序,将得到两个有序序列,然后将这两个序列归并成一个序列即可

执行过程

代码

时间复杂度

### 基数类排序

#### 基数排序
思想
- 多关键字排序

执行过程

代码

时间复杂度

### 外部排序
思想

执行过程

代码

时间复杂度

### 各种排序算法的比较

### 排序算法的应用