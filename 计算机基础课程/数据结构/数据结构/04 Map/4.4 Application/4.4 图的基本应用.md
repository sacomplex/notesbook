# 图的基本应用

## 最小(代价)生成树

### 普里姆算法(Prim算法)和克鲁斯卡尔算法(Kruskal算法)

#### 普里姆算法(Prim算法)
思想
- 从图中任意取出一个顶点,把它当做一棵树,然后从与这棵树相接的边中选取一条最短(权值最小)的边,并将这条边及其连接的顶点也并入这棵树,此时得到了一颗有两个顶点的树
- 然后从与这颗树相接的边中选取一条最短的边,并将这条边及其所连顶点并入当前树中,得到一颗有3个顶点的树
- 以此类推,直到图中所有顶点都被并入树中为止,此时得到的生成树就是最小生成树

执行过程

算法代码

时间复杂度分析
- $O(n^2)$
- 适用于稠密图
	- 时间复杂度只与图中顶点有关系

#### 克鲁斯卡尔算法(Kruskal算法)
思想
- 每次找出候选边中权值最小的边,就将该边并入生成树中,重复此过程直到所有边都被检测完为止

执行过程

算法代码

时间复杂度分析
- 一般大于常量级
- 适用于稀疏图
	- 主要与图的边数有关,与顶点数无关

## 最短路径

### 迪杰斯特拉算法(Dijkstra算法)
思想
- 设有两个顶点集合S和T
  - 集合S中存放图中已经找到最短路径的顶点
  - 集合T存放图中剩余顶点
- 初始状态
  - 集合S中值包含源点$v_0$
- 然后不断从集合T中选取到顶点$v_0$路径长度最短的顶点$v_u$并入到集合$S$中
- 集合S没并入一个新的顶点$v_u$,都要修改$v_0$到集合T中顶点的最短路径长度值
- 不断重复此过程,直到集合T中的顶点全部并入到S为止

执行过程

算法代码

时间复杂度分析

### 弗洛伊德算法(Floyd算法)
求图中任意一对顶点间的最短路径

思想
- 设置两个矩阵A和Path,初始时将图的邻接矩阵赋值给A,将矩阵Path中元素全部设置为-1
- 以顶点k为中间顶点,$k \in [0,n-1]$(n为顶点数),对图中所有顶点对${i,j}$进行如下检测与修改
- 如果$A[i][j] > A[i][k] + A[k][j]$,则将$A[i][j]$改为$A[i][k]+A[k][j]$的值,将$Path[i][j]$改为k,否则什么都不做

执行过程

算法代码

时间复杂度分析

## 拓扑排序

### AOV网
AOV网

- 一种以顶点表示活动,以边表示活动的先后次序且没有回路的有向图
- 用于表示整个工程中各个活动之间的先后关系的有向图

### 拓扑排序的核心算法
对一个有向无环图G进行拓扑排序,是将G中所有顶点排成一个线性序列,使得图中任意一对顶点u和v,若存在由u到v的路径,则在拓扑排序序列中一定是u出现在v的前边



在一个有向图中寻找一个拓扑排序序列的过程

- 第一步: 从有向图中选择一个没有前驱(入度为0)的顶点输出
- 第二步: 删除第一步中的顶点,并且删除从该顶点出发的全部边
- 重复上述过程,直到剩余的图中不存在没有前驱的顶点为止


## 关键路径

### AOE网

### AOV网

### 关键路径核心算法

