/********************************************
 * TeX中的引号（ Tex Quotes, UVa 272） 
 * 在TeX中， 左双引号是“``”， 右双引号是“"”。 输入一篇包含双引号的文章， 你的任务是把它转换成TeX的格式。
 * 
 * 样例输入：
 * "To be or not to be," quoth the Bard, "that 
 * is the question".
 * 样例输出：
 * ``To be or not to be," quoth the Bard, ``that 
 * is the question".
 * *******************************************/
/*********************************************
 * 分析
 * 如何判断一个双引号是左双引号还是右双引号
 * 输入字符串
 *    scanf("%s")不能在本题中使用它， 因为它碰到空格或者TAB就会停下来。 
 *    
 * 解决方法一
 *     fgetc(fin):
 *        使用“fgetc(fin)”， 它读取一个打开的文件fin， 读取一个字符， 然后返回一个int值。 
 *        为什么返回的是int而不是char呢？ 因为如果文件结束， fgetc将返回一个特殊标记EOF， 它并不是一个char。 
 *        如果把fgetc(fin)的返回值强制转换为char， 将无法把特殊的EOF和普通字符区分开。
 *     getchar:
 *        如果要从标准输入读取一个字符， 可以用getchar， 它等价于fgetc(stdin)。 
 *    
 * 注意:
 *    1. fgetc和getchar将读取“下一个字符”， 因此需要知道在各种情况下， “下一个字符”是哪个。 
 *       如果用“scanf("%d", &n)”读取整数n， 则要是在输入123后多加了一个空格， 用getchar读取的将是这个空格； 
 *       如果在“123”之后紧跟着换行， 则读取到的将是回车符“\n”。
 *    2. 不同操作系统的回车换行符是不一致的
 *       Windows是“\r”和“\n”两个字符， Linux是“\n”， 而MacOS是“\r”。
 *       如果在Windows下读取Windows文件， fgetc和getchar会把“\r""吃掉”， 只剩下“\n”； 
 *       但如果要在Linux下读取同样一个文件， 它们会忠实地先读取“\r”， 然后才是“\n”。  
 *    
 *    
 * 解决方法二
 *    fgets(buf, maxn, fin)
 *      使用“fgets(buf, maxn, fin)”读取完整的一行， 其中buf的声明为charbuf[maxn]。 
 *      这个函数读取不超过maxn-1个字符， 然后在末尾添上结束符“\0”， 因此不会出现越界的情况。 
 *      之所以说可以用这个函数读取完整的一行， 是因为一旦读到回车符“\n”， 读取工作将会停止， 
 *    而这个“\n”也会是buf字符串中最后一个有效字符（ 再往后就是字符串结束符“\0”了） 。 
 *      只有在一种情况下， buf不会以“\n”结尾： 读到文件结束符， 并且文件的最后一个不是以“\n”结尾。
 *    
 * 注意:
 *    1."fgets(buf, maxn, fin)"将读取完整的一行放在字符数组buf中
 *      应当保证buf足够存放下文件的一行内容。 
 *      除了在文件结束前没有遇到“\n”这种特殊情况外， buf总是以“\n”结尾。 
 *      当一个字符都没有读到时， fgets返回NULL。
 *    2. fgets对应的gets函数已经在C11标准被废除
 *      gets函数,没有指明读取的最大字符数,可能存在缓冲区溢出漏洞
 *    
 * *******************************************/
# include<cstdio>

int main(){
    int c;
    int q = 1;
    while ((c = getchar()) != EOF){
        if(c == '"')
            {
                printf("%s", q ? "``" : "''");
                q =! q; // 跳过匹配右括号
            }
        else 
            printf("%c", c);
    }
    return 0;
}
